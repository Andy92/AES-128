// reading an entire binary file
#include <iostream>
#include <fstream>
#include  <iomanip>
#include  <vector>
using namespace std;

const bool DEBUGGING = false; 
const int BLOCKSIZE = 16;
 unsigned char s[256] = 
 {
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
 };


unsigned int shift_rows_table[16] = {0,5,10,15,4,9,14,3,8,13,2,7,12,1,6,11};

 unsigned char lookup_g2[256] = 
{
0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};



unsigned char lookup_g3[256] = 
{
0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};
/*
// A 4x4 matrix evaluator
[0 4 8  12
 1 5 9  13
 2 6 10 14
 3 7 11 15]
*/
int getMatrix(int x, int y) {
	int res = x * 4 + y;
	return res;
}
/*
void addRoundKey() {

 }
*/
/*
* Rotates the 4 byte word 1 byte to the left.
*/
void rotate(unsigned char * word) {
	unsigned char tmp = word[0];
	word[0] = word[1];
	word[1] = word[2];
	word[2] = word[3];
	word[3] = tmp;
	//return word;
}

int rcon(int i) {
	if(i == 1)
		return 1;
	return 2 * rcon(i-1);
}

/*
On just the first (leftmost) byte of the output word, 
exclusive OR the byte with 2 to the power of (i-1) in Rijndael's 
finite field. In other words, perform the rcon operation with i as the input,
 and exclusive or the rcon output with the first byte of the output word
*/
void key_schedule_core(unsigned char * t, int rconi) {
	if(DEBUGGING) {
		// #########################
		for(int i=0;i<4;++i) {
			printf("%02hhX", t[i]);
			cout << " ";
		}
		cout << endl << "rotate" << endl;
		// #########################
	}
	rotate(t);
	if(DEBUGGING) {
		// #########################
		for(int i=0;i<4;++i) {
			printf("%02hhX", t[i]);
			cout << " ";
		}
		cout << endl << "rotate" << endl;
		// #########################
	}
	// #########################
	for(int i=0;i<4;++i) {
		t[i] = (unsigned char)s[t[i]];
		if(DEBUGGING) { 
			printf("%02hhX", t[i]);
			cout << " ";
		}
	}
	if(DEBUGGING) {
	cout << endl << "sbox" << endl;
		// #########################
	}
	//cout << rcon(rconi);
	t[0] = ( t[0] ^ rcon(rconi) );
	// printf("%02hhX\n", t[0]);

}

unsigned char * rijndael(unsigned char * inital_key) {

	int n = 16;
	int b = 176;
	unsigned char * expanded_key = new unsigned char[b];
	int sizeOfExpanded = n;
	for(int i=0;i<n;++i) {
		expanded_key[i] = inital_key[i];
	}
	int rconi = 1;


	// key schedule
	while(sizeOfExpanded != b) {
		unsigned char * t = new unsigned char[4];
		for(int i=0;i<4;++i) {
			t[i] = expanded_key[sizeOfExpanded-4+i]; // Assign last 4 bytes to t.
		}
		cout << endl;
		key_schedule_core(t, rconi);
		rconi++;
		if(DEBUGGING) {
			// #########################
			for(int i=0;i<4;++i) {
				printf("%02hhX", t[i]);
				cout << " ";
			}
			cout << endl;
		}
	// #########################
// We exclusive-OR t with the four-byte block n 
// bytes before the new expanded key. This becomes the next 4 bytes in the expanded key
		// We do this 4 times to create n=16 bytes of key.
		for(int i=0;i<4;++i) {
			for(int j=0;j<4;++j) {
				expanded_key[sizeOfExpanded+j] = ( t[j] ^ expanded_key[sizeOfExpanded-4+j] );
				t[j] = expanded_key[sizeOfExpanded+j];
			}
			sizeOfExpanded += 4;
		}
		if(DEBUGGING) {
			cout << "After the key expansion." << endl;
			// #########################
			for(int i=0;i<sizeOfExpanded;++i) {
				printf("%02hhX", expanded_key[i]);
				cout << " ";
			}
			cout << endl;
			// #########################
		}
		
	}
	return expanded_key;
}

void addRoundKey(unsigned char * roundKey, unsigned char * block, int round) {
	for(int i;i<BLOCKSIZE;++i) {
		block[i] = block[i] ^ roundKey[i+round*16];
	}
}

// Using the S-Box we substitute each byte.
void subBytes(unsigned char * block) {
	for(int i=0;i<BLOCKSIZE;++i) {
		block[i] = (unsigned char)s[block[i]];
	}
}
void shiftRows(unsigned char * block) {
	unsigned char * t = new unsigned char[4];
	for(int i=0;i<4;++i) {
		t[i] = block[4+i];
	}
	rotate(t);

	for(int i=0;i<4;++i) {
		block[4+i] = t[i];
		t[i] = block[8+i];
	}
	rotate(t);
	rotate(t);

	for(int i=0;i<4;++i) {
		block[8+i] = t[i];
		t[i] = block[12+i];
	}
	rotate(t);
	rotate(t);
	rotate(t);

	for(int i=0;i<4;++i) {
		block[12+i] = t[i];
	}
}
void mixColumn(unsigned char * blockColumn, int i) {
	unsigned char * a = new unsigned char[4];

	a[0] = blockColumn[getMatrix(i,0)];
	a[1] = blockColumn[getMatrix(i,1)];
	a[2] = blockColumn[getMatrix(i,2)];
	a[3] = blockColumn[getMatrix(i,3)];
	blockColumn[getMatrix(i,0)] = (unsigned char)(lookup_g2[a[0]] ^ lookup_g3[a[1]] ^ a[2] 		   ^ a[3]);
	blockColumn[getMatrix(i,1)] = (unsigned char)(a[0] 		   ^ lookup_g2[a[1]] ^ lookup_g3[a[2]] ^ a[3]);
	blockColumn[getMatrix(i,2)] = (unsigned char)(a[0] 		   ^ a[1] 		   ^ lookup_g2[a[2]] ^ lookup_g3[a[3]]);
	blockColumn[getMatrix(i,3)] = (unsigned char)(lookup_g3[a[0]] ^ a[1] 		   ^ a[2] 		   ^ lookup_g2[a[3]]);

}
/*
* MixColumns
*/
void mixColumns(unsigned char * block) {
	if(DEBUGGING) {
		for(int i=0;i<4;++i) {
			printf("%02hhX", block[getMatrix(0,i)]);
			cout << " ";
		}
		cout << endl;
	}
	for (int i=0;i<4;++i) {
		mixColumn(block, i);
	}
	if(DEBUGGING) {
		for(int i=0;i<4;++i) {
			printf("%02hhX", block[getMatrix(0,i)]);
			cout << " ";
		}
		cout << endl;
	}

}
/*
10 cycles of repetition for 128-bit keys.

Each round consists of several processing steps,
 each containing four similar but different stages,
  including one that depends on the encryption key itself.
   A set of reverse rounds are applied to transform ciphertext
    back into the original plaintext using the same encryption key.
*/
unsigned char * encrypt(unsigned char * key, unsigned char * block) {
	unsigned char * encryptedBlock = new unsigned char[BLOCKSIZE];
	for (int i = 0; i < BLOCKSIZE; ++i) {
		encryptedBlock[i] = block[i];
	}
	// Key expansion
	unsigned char * roundKey = rijndael(key);

	// Initial round
	addRoundKey(roundKey, encryptedBlock, 0);

	// Round 1 to 10
	for(int round=1;round<10;++round) {
		subBytes(encryptedBlock);
		shiftRows(encryptedBlock);
		mixColumns(encryptedBlock);
		addRoundKey(roundKey, encryptedBlock, round);
	}
	
	// Final Round
	subBytes(encryptedBlock);
	shiftRows(encryptedBlock);
	addRoundKey(roundKey, encryptedBlock, 10);

	return encryptedBlock;
}

int main () {
  streampos size;
  char * memblock;
  bool reading_key = true;
  unsigned char * aes_key = new unsigned char[BLOCKSIZE];
  unsigned char * block = new unsigned char[BLOCKSIZE];
  ifstream file ("aes_sample.in", ios::in|ios::binary|ios::ate);
  if (file.is_open())
  {
    size = file.tellg();
    memblock = new char [size];
    file.seekg (0, ios::beg);
    file.read (memblock, size);
    file.close();

    cout << "size: " << size << " bytes" << endl;
    cout << "output: ";
    for(int i=0;i<size;++i) {
		printf("%02hhX", memblock[i]);
		if(reading_key) {
			aes_key[i] = memblock[i]; // Read key.
		} else {
			block[i % 16] = memblock[i]; // Read last block.
		}

		if((i % 16) == 15 ) {	// New line every 16 bytes
			cout << endl << "       ";
			reading_key = false;
		}

		cout << " ";
	}
	cout << endl;

	unsigned char * encryptedBlock = encrypt(aes_key, block);

	cout << "encrypted: ";
	for(int i=0;i<BLOCKSIZE;++i) {
		printf("%02hhX", encryptedBlock[i]);
		cout << " ";
	}
	cout << endl;

    delete[] memblock;
  }
  else cout << "Unable to open file";
  delete[] aes_key;
  return 0;
}

/*
int main()
{
  unsigned char c = 'n';
  cout << "HEX " << hex << (int)c << endl;  // output in hexadecimal
  cout << "ASC" << c << endl; // output in ascii
  return 0;
}
*/